#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CommonConversationRuntime

#include "Basic.hpp"

#include "CommonConversationRuntime_classes.hpp"
#include "CommonConversationRuntime_parameters.hpp"


namespace SDK
{

// Function CommonConversationRuntime.ConversationNode.GetDebugParticipantColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ParticipantID                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UConversationNode::GetDebugParticipantColor(const struct FGameplayTag& ParticipantID) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDebugParticipantColor");

	Params::ConversationNode_GetDebugParticipantColor Parms{};

	Parms.ParticipantID = std::move(ParticipantID);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ClientExecuteTaskAndSideEffects
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FConversationNodeHandle          Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ClientExecuteTaskAndSideEffects(const struct FConversationNodeHandle& Handle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientExecuteTaskAndSideEffects");

	Params::ConversationParticipantComponent_ClientExecuteTaskAndSideEffects Parms{};

	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ClientStartConversation
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FGameplayTag                     AsParticipant                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ClientStartConversation(const struct FGameplayTag& AsParticipant)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStartConversation");

	Params::ConversationParticipantComponent_ClientStartConversation Parms{};

	Parms.AsParticipant = std::move(AsParticipant);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ClientUpdateConversation
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FClientConversationMessagePayloadMessage                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ClientUpdateConversation(const struct FClientConversationMessagePayload& Message)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUpdateConversation");

	Params::ConversationParticipantComponent_ClientUpdateConversation Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ClientUpdateConversations
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                                   InConversationsActive                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ClientUpdateConversations(int32 InConversationsActive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUpdateConversations");

	Params::ConversationParticipantComponent_ClientUpdateConversations Parms{};

	Parms.InConversationsActive = InConversationsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ClientUpdateConversationTaskChoiceData
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FConversationNodeHandle          Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FClientConversationOptionEntry   OptionEntry                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ClientUpdateConversationTaskChoiceData(const struct FConversationNodeHandle& Handle, const struct FClientConversationOptionEntry& OptionEntry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUpdateConversationTaskChoiceData");

	Params::ConversationParticipantComponent_ClientUpdateConversationTaskChoiceData Parms{};

	Parms.Handle = std::move(Handle);
	Parms.OptionEntry = std::move(OptionEntry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ClientUpdateParticipants
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FConversationParticipants        InParticipants                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ClientUpdateParticipants(const struct FConversationParticipants& InParticipants)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUpdateParticipants");

	Params::ConversationParticipantComponent_ClientUpdateParticipants Parms{};

	Parms.InParticipants = std::move(InParticipants);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.GetParticipantDisplayName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UConversationParticipantComponent::GetParticipantDisplayName()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParticipantDisplayName");

	Params::ConversationParticipantComponent_GetParticipantDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationParticipantComponent.OnRep_ConversationsActive
// (Final, Native, Protected)
// Parameters:
// int32                                   OldConversationsActive                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::OnRep_ConversationsActive(int32 OldConversationsActive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ConversationsActive");

	Params::ConversationParticipantComponent_OnRep_ConversationsActive Parms{};

	Parms.OldConversationsActive = OldConversationsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.RequestServerAdvanceConversation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAdvanceConversationRequest      InChoicePicked                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::RequestServerAdvanceConversation(const struct FAdvanceConversationRequest& InChoicePicked)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestServerAdvanceConversation");

	Params::ConversationParticipantComponent_RequestServerAdvanceConversation Parms{};

	Parms.InChoicePicked = std::move(InChoicePicked);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.ServerAdvanceConversation
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FAdvanceConversationRequest      InChoicePicked                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationParticipantComponent::ServerAdvanceConversation(const struct FAdvanceConversationRequest& InChoicePicked)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerAdvanceConversation");

	Params::ConversationParticipantComponent_ServerAdvanceConversation Parms{};

	Parms.InChoicePicked = std::move(InChoicePicked);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationParticipantComponent.IsInActiveConversation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationParticipantComponent::IsInActiveConversation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInActiveConversation");

	Params::ConversationParticipantComponent_IsInActiveConversation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationChoiceNode.FillChoice
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FClientConversationOptionEntry   ChoiceEntry                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UConversationChoiceNode::FillChoice(const struct FConversationContext& Context, struct FClientConversationOptionEntry* ChoiceEntry) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FillChoice");

	Params::ConversationChoiceNode_FillChoice Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	if (ChoiceEntry != nullptr)
		*ChoiceEntry = std::move(Parms.ChoiceEntry);
}


// Function CommonConversationRuntime.ConversationContextHelpers.AbortConversation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::AbortConversation(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AbortConversation");

	Params::ConversationContextHelpers_AbortConversation Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.AdvanceConversation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::AdvanceConversation(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AdvanceConversation");

	Params::ConversationContextHelpers_AdvanceConversation Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.AdvanceConversationWithChoice
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FAdvanceConversationRequest      Choice                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::AdvanceConversationWithChoice(const struct FConversationContext& Context, const struct FAdvanceConversationRequest& Choice)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AdvanceConversationWithChoice");

	Params::ConversationContextHelpers_AdvanceConversationWithChoice Parms{};

	Parms.Context = std::move(Context);
	Parms.Choice = std::move(Choice);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.CanConversationContinue
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationTaskResult          ConversationTasResult                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationContextHelpers::CanConversationContinue(const struct FConversationTaskResult& ConversationTasResult)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CanConversationContinue");

	Params::ConversationContextHelpers_CanConversationContinue Parms{};

	Parms.ConversationTasResult = std::move(ConversationTasResult);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.FindConversationComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationParticipantComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConversationParticipantComponent* UConversationContextHelpers::FindConversationComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindConversationComponent");

	Params::ConversationContextHelpers_FindConversationComponent Parms{};

	Parms.Actor = Actor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.GetConversationInstance
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UConversationInstance*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConversationInstance* UConversationContextHelpers::GetConversationInstance(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConversationInstance");

	Params::ConversationContextHelpers_GetConversationInstance Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.GetConversationParticipant
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ParticipantTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationParticipantComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConversationParticipantComponent* UConversationContextHelpers::GetConversationParticipant(const struct FConversationContext& Context, const struct FGameplayTag& ParticipantTag)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConversationParticipant");

	Params::ConversationContextHelpers_GetConversationParticipant Parms{};

	Parms.Context = std::move(Context);
	Parms.ParticipantTag = std::move(ParticipantTag);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.GetConversationParticipantActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ParticipantTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UConversationContextHelpers::GetConversationParticipantActor(const struct FConversationContext& Context, const struct FGameplayTag& ParticipantTag)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConversationParticipantActor");

	Params::ConversationContextHelpers_GetConversationParticipantActor Parms{};

	Parms.Context = std::move(Context);
	Parms.ParticipantTag = std::move(ParticipantTag);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.GetCurrentConversationNodeHandle
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationNodeHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FConversationNodeHandle UConversationContextHelpers::GetCurrentConversationNodeHandle(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentConversationNodeHandle");

	Params::ConversationContextHelpers_GetCurrentConversationNodeHandle Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.MakeConversationParticipant
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           ParticipantActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ParticipantTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationContextHelpers::MakeConversationParticipant(const struct FConversationContext& Context, class AActor* ParticipantActor, const struct FGameplayTag& ParticipantTag)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeConversationParticipant");

	Params::ConversationContextHelpers_MakeConversationParticipant Parms{};

	Parms.Context = std::move(Context);
	Parms.ParticipantActor = ParticipantActor;
	Parms.ParticipantTag = std::move(ParticipantTag);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationContextHelpers.PauseConversationAndSendClientChoices
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FClientConversationMessage       Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::PauseConversationAndSendClientChoices(const struct FConversationContext& Context, const struct FClientConversationMessage& Message)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PauseConversationAndSendClientChoices");

	Params::ConversationContextHelpers_PauseConversationAndSendClientChoices Parms{};

	Parms.Context = std::move(Context);
	Parms.Message = std::move(Message);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.ReturnToConversationStart
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::ReturnToConversationStart(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReturnToConversationStart");

	Params::ConversationContextHelpers_ReturnToConversationStart Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.ReturnToCurrentClientChoice
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::ReturnToCurrentClientChoice(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReturnToCurrentClientChoice");

	Params::ConversationContextHelpers_ReturnToCurrentClientChoice Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationContextHelpers.ReturnToLastClientChoice
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationContextHelpers::ReturnToLastClientChoice(const struct FConversationContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReturnToLastClientChoice");

	Params::ConversationContextHelpers_ReturnToLastClientChoice Parms{};

	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationLibrary.StartConversation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ConversationEntryTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InstigatorTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TargetTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationInstance*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConversationInstance* UConversationLibrary::StartConversation(const struct FGameplayTag& ConversationEntryTag, class AActor* Instigator, const struct FGameplayTag& InstigatorTag, class AActor* Target, const struct FGameplayTag& TargetTag)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StartConversation");

	Params::ConversationLibrary_StartConversation Parms{};

	Parms.ConversationEntryTag = std::move(ConversationEntryTag);
	Parms.Instigator = Instigator;
	Parms.InstigatorTag = std::move(InstigatorTag);
	Parms.Target = Target;
	Parms.TargetTag = std::move(TargetTag);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationTaskNode.ExecuteClientEffects
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UConversationTaskNode::ExecuteClientEffects(const struct FConversationContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ExecuteClientEffects");

	Params::ConversationTaskNode_ExecuteClientEffects Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationTaskNode.ExecuteTaskNode
// (BlueprintAuthorityOnly, Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FConversationTaskResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationTaskResult UConversationTaskNode::ExecuteTaskNode(const struct FConversationContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ExecuteTaskNode");

	Params::ConversationTaskNode_ExecuteTaskNode Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationTaskNode.GatherStaticExtraData
// (BlueprintAuthorityOnly, Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FConversationNodeParameterPair>InOutExtraData                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UConversationTaskNode::GatherStaticExtraData(const struct FConversationContext& Context, TArray<struct FConversationNodeParameterPair>* InOutExtraData) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GatherStaticExtraData");

	Params::ConversationTaskNode_GatherStaticExtraData Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	if (InOutExtraData != nullptr)
		*InOutExtraData = std::move(Parms.InOutExtraData);
}


// Function CommonConversationRuntime.ConversationTaskNode.GetNodeBodyColor
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FLinearColor                     BodyColor                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationTaskNode::GetNodeBodyColor(struct FLinearColor* BodyColor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNodeBodyColor");

	Params::ConversationTaskNode_GetNodeBodyColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BodyColor != nullptr)
		*BodyColor = std::move(Parms.BodyColor);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationTaskNode.IsRequirementSatisfied
// (BlueprintAuthorityOnly, Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EConversationRequirementResult          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConversationRequirementResult UConversationTaskNode::IsRequirementSatisfied(const struct FConversationContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsRequirementSatisfied");

	Params::ConversationTaskNode_IsRequirementSatisfied Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationRequirementNode.IsRequirementSatisfied
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EConversationRequirementResult          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConversationRequirementResult UConversationRequirementNode::IsRequirementSatisfied(const struct FConversationContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsRequirementSatisfied");

	Params::ConversationRequirementNode_IsRequirementSatisfied Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CommonConversationRuntime.ConversationSideEffectNode.ClientCauseSideEffect
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UConversationSideEffectNode::ClientCauseSideEffect(const struct FConversationContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCauseSideEffect");

	Params::ConversationSideEffectNode_ClientCauseSideEffect Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonConversationRuntime.ConversationSideEffectNode.ServerCauseSideEffect
// (BlueprintAuthorityOnly, Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FConversationContext             Context                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UConversationSideEffectNode::ServerCauseSideEffect(const struct FConversationContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerCauseSideEffect");

	Params::ConversationSideEffectNode_ServerCauseSideEffect Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);
}

}

